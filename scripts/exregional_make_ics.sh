#!/bin/bash

#
#-----------------------------------------------------------------------
#
# Source the variable definitions file and the bash utility functions.
#
#-----------------------------------------------------------------------
#
. ${GLOBAL_VAR_DEFNS_FP}
. $USHDIR/source_util_funcs.sh
#
#-----------------------------------------------------------------------
#
# Save current shell options (in a global array).  Then set new options
# for this script/function.
#
#-----------------------------------------------------------------------
#
{ save_shell_opts; set -u +x; } > /dev/null 2>&1
#
#-----------------------------------------------------------------------
#
# Get the full path to the file in which this script/function is located
# (scrfunc_fp), the name of that file (scrfunc_fn), and the directory in
# which the file is located (scrfunc_dir).
#
#-----------------------------------------------------------------------
#
scrfunc_fp=$( readlink -f "${BASH_SOURCE[0]}" )
scrfunc_fn=$( basename "${scrfunc_fp}" )
scrfunc_dir=$( dirname "${scrfunc_fp}" )
#
#-----------------------------------------------------------------------
#
# Print message indicating entry into script.
#
#-----------------------------------------------------------------------
#
print_info_msg "
========================================================================
Entering script:  \"${scrfunc_fn}\"
In directory:     \"${scrfunc_dir}\"

This is the ex-script for the task that generates initial condition 
(IC), surface, and zeroth hour lateral boundary condition (LBC0) files 
for FV3 (in NetCDF format).
========================================================================"
#
#-----------------------------------------------------------------------
#
# Specify the set of valid argument names for this script/function.  Then 
# process the arguments provided to this script/function (which should 
# consist of a set of name-value pairs of the form arg1="value1", etc).
#
#-----------------------------------------------------------------------
#
valid_args=( \
"ics_dir" \
"APRUN" \
)
process_args valid_args "$@"
#
#-----------------------------------------------------------------------
#
# For debugging purposes, print out values of arguments passed to this
# script.  Note that these will be printed out only if VERBOSE is set to
# TRUE.
#
#-----------------------------------------------------------------------
#
print_input_args valid_args
#                                                                        
#----------------------------------------------------------------------- 
#                                                                        
# Source the file containing definitions of variables associated with the 
# external model for ICs.
#                                                                        
#----------------------------------------------------------------------- 
#                                                                        
extrn_mdl_staging_dir="${CYCLE_DIR}/${EXTRN_MDL_NAME_ICS}/ICS"             
extrn_mdl_var_defns_fp="${extrn_mdl_staging_dir}/${EXTRN_MDL_ICS_VAR_DEFNS_FN}"      
. ${extrn_mdl_var_defns_fp}                                                   
#
#-----------------------------------------------------------------------
#
#
#
#-----------------------------------------------------------------------
#
workdir="${ics_dir}/tmp_ICS"
mkdir_vrfy -p "$workdir"
cd_vrfy $workdir
#
#-----------------------------------------------------------------------
#
# Set physics-suite-dependent variables that are needed in the FORTRAN
# namelist file that the chgres executable will read in.
#
#-----------------------------------------------------------------------
#
varmap_file=""

case "${CCPP_PHYS_SUITE}" in

"FV3_GFS_2017_gfdlmp" | "FV3_GFS_2017_gfdlmp_regional" | "FV3_GFS_v16beta" | \
"FV3_GFS_v15p2" )
  varmap_file="GFSphys_var_map.txt"
  ;;
"FV3_GSD_v0" | "FV3_GSD_SAR" | "FV3_GSD_SAR_v1" |"FV3_RRFS_v0" )
  varmap_file="GSDphys_var_map.txt"
  ;;
*)
  print_err_msg_exit "\
Physics-suite-dependent namelist variables have not yet been specified in a
varmap table for this physics suite:
  CCPP_PHYS_SUITE = \"${CCPP_PHYS_SUITE}\""
  ;;

esac
#
#-----------------------------------------------------------------------
#
# Set external-model-dependent variables that are needed in the FORTRAN
# namelist file that the chgres executable will read in.  These are de-
# scribed below.  Note that for a given external model, usually only a
# subset of these all variables are set (since some may be irrelevant).
#
# external_model:
# Name of the external model from which we are obtaining the fields 
# needed to generate the ICs.
#
# fn_atm_nemsio:
# Name (not including path) of the nemsio file generated by the external
# model that contains the atmospheric fields.
#
# fn_sfc_nemsio:
# Name (not including path) of the nemsio file generated by the external
# model that contains the surface fields.
#
# input_type:
# The "type" of input being provided to chgres.  This contains a combi-
# nation of information on the external model, external model file for-
# mat, and maybe other parameters.  For clarity, it would be best to 
# eliminate this variable in chgres and replace with with 2 or 3 others
# (e.g. extrn_mdl, extrn_mdl_file_format, etc).
# 
# nsoill_out:
# The number of soil layers to include in the output NetCDF file.
#
# FIELD_from_climo, where FIELD = "vgtyp", "sotyp", "vgfrc", "lai", or 
# "minmax_vgfrc":
# Logical variable indicating whether or not to obtain the field in 
# question from climatology instead of the external model.  The field in
# question is one of vegetation type (FIELD="vgtyp"), soil type (FIELD=
# "sotyp"), vegetation fraction (FIELD="vgfrc"), leaf area index 
# (FIELD="lai"), or min/max areal fractional coverage of annual green 
# vegetation (FIELD="minmax_vfrr").  If FIELD_from_climo is set to 
# ".true.", then the field is obtained from climatology (regardless of
# whether or not it exists in an external model file).  If it is set
# to ".false.", then the field is obtained from the external  model.
# If "false" is chosen and the external model file does not provide
# this field, then chgres_cube prints out an error message and stops.
#
# tg3_from_soil:
# Logical variable indicating whether or not to set the tg3 soil tempe-  # Needs to be verified.
# rature field to the temperature of the deepest soil layer. 
#
#-----------------------------------------------------------------------
#

external_model=""
fn_atm_nemsio=""
fn_sfc_nemsio=""
fn_grib2=""
input_type=""
nsoill_out=""
geogrid_file_input_grid="\"\""
vgtyp_from_climo=""
sotyp_from_climo=""
vgfrc_from_climo=""
minmax_vgfrc_from_climo=""
lai_from_climo=""
tg3_from_soil=""
convert_nst=""


case "${EXTRN_MDL_NAME_ICS}" in


"GSMGFS")

  external_model="GSMGFS"

  fn_atm_nemsio="${EXTRN_MDL_FNS[0]}"
  fn_sfc_nemsio="${EXTRN_MDL_FNS[1]}"
  input_type="gfs_gaussian" # For spectral GFS Gaussian grid in nemsio format.

  nsoill_out="4"
  vgtyp_from_climo=True
  sotyp_from_climo=True
  vgfrc_from_climo=True
  minmax_vgfrc_from_climo=True
  lai_from_climo=True
  tg3_from_soil=False
  convert_nst=False

  ;;


"FV3GFS")

  if [ "${FV3GFS_FILE_FMT_ICS}" = "nemsio" ]; then

    external_model="FV3GFS"

    fn_atm_nemsio="${EXTRN_MDL_FNS[0]}"
    fn_sfc_nemsio="${EXTRN_MDL_FNS[1]}"
    input_type="gaussian"     # For FV3-GFS Gaussian grid in nemsio format.

  elif [ "${FV3GFS_FILE_FMT_ICS}" = "grib2" ]; then

    external_model="GFS"

    fn_grib2="${EXTRN_MDL_FNS[0]}"
    input_type="grib2"

  fi

  nsoill_out="4"
  vgtyp_from_climo=True
  sotyp_from_climo=True
  vgfrc_from_climo=True
  minmax_vgfrc_from_climo=True
  lai_from_climo=True
  tg3_from_soil=False
  convert_nst=True

  ;;


"HRRRX")

  external_model="HRRR"

  fn_grib2="${EXTRN_MDL_FNS[0]}"
  input_type="grib2"

  if [ "${USE_CCPP}" = "TRUE" ]; then
    if [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_2017_gfdlmp" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_SAR_v1" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_RRFS_v0" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_CPT_v0" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_v15p2" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_v16beta" ]; then
      nsoill_out="4"
    elif [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_v0" ] || \
         [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_SAR" ]; then
      nsoill_out="9"
    fi
  fi
#
# These geogrid files need to be moved to more permanent locations.
#
  if [ "${MACHINE}" = "HERA" ]; then
    geogrid_file_input_grid="/scratch2/BMC/det/beck/FV3-SAR/geo_em.d01.nc_HRRRX"
  elif [ "${MACHINE}" = "JET" ]; then
    geogrid_file_input_grid="/misc/whome/rtrr/HRRR/static/WPS/geo_em.d01.nc"
  fi


  #Note that vgfrc, shdmin/shdmax (minmax_vgfrc), and lai fields are only available in HRRRX 
  #files after mid-July 2019, and only so long as the record order didn't change afterward

  vgtyp_from_climo=False
  sotyp_from_climo=False
  vgfrc_from_climo=False
  minmax_vgfrc_from_climo=False
  lai_from_climo=False
  tg3_from_soil=True
  convert_nst=False

  ;;

"RAPX")

  external_model="RAP"

  fn_grib2="${EXTRN_MDL_FNS[0]}"
  input_type="grib2"

  if [ "${USE_CCPP}" = "TRUE" ]; then
    if [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_2017_gfdlmp" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_CPT_v0" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_SAR_v1" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_RRFS_v0" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_v15p2" ] || \
       [ "${CCPP_PHYS_SUITE}" = "FV3_GFS_v16beta" ]; then
      nsoill_out="4"
    elif [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_v0" ] || \
         [ "${CCPP_PHYS_SUITE}" = "FV3_GSD_SAR" ]; then
      nsoill_out="9"
    fi
  fi
#
# These geogrid files need to be moved to more permanent locations.
#
  if [ "${MACHINE}" = "HERA" ]; then
    geogrid_file_input_grid="/scratch2/BMC/det/beck/FV3-SAR/geo_em.d01.nc_RAPX"
  elif [ "${MACHINE}" = "JET" ]; then
    geogrid_file_input_grid="/misc/whome/rtrr/HRRR/static/WPS/geo_em.d01.nc"
  fi

  vgtyp_from_climo=True
  sotyp_from_climo=False
  vgfrc_from_climo=True
  minmax_vgfrc_from_climo=True
  lai_from_climo=True
  tg3_from_soil=True
  convert_nst=False

  ;;

*)
  print_err_msg_exit "\
External-model-dependent namelist variables have not yet been specified 
for this external model:
  EXTRN_MDL_NAME_ICS = \"${EXTRN_MDL_NAME_ICS}\""
  ;;

esac
#
#-----------------------------------------------------------------------
#
# Get the starting month, day, and hour of the the external model forecast.
#
#-----------------------------------------------------------------------
#
mm="${EXTRN_MDL_CDATE:4:2}"
dd="${EXTRN_MDL_CDATE:6:2}"
hh="${EXTRN_MDL_CDATE:8:2}"
#
#-----------------------------------------------------------------------
#
# Check that the executable that generates the ICs exists.
#
#-----------------------------------------------------------------------
#
exec_fn="chgres_cube.exe"
exec_fp="$EXECDIR/${exec_fn}"                                            
if [ ! -f "${exec_fp}" ]; then                                           
  print_err_msg_exit "\                                                  
The executable (exec_fp) for generating initial conditions on the FV3SAR
native grid does not exist:                  
  exec_fp = \"${exec_fp}\"                                               
Please ensure that you've built this executable."                        
fi                                                                       
#
#-----------------------------------------------------------------------
#
# Build the FORTRAN namelist file that chgres_cube will read in.
#
#-----------------------------------------------------------------------
#
# fix_dir_target_grid="${BASEDIR}/JP_grid_HRRR_like_fix_files_chgres_cube"
# base_install_dir="${SORCDIR}/chgres_cube.fd"

#
# Create a multiline variable that consists of a yaml-compliant string
# specifying the values that the namelist variables need to be set to
# (one namelist variable per line, plus a header and footer).  Below,
# this variable will be passed to a python script that will create the
# namelist file.
#
settings="
'config': {
 'fix_dir_input_grid': ${CHGRES_CUBE_DIR}/fix/fix_chgres,
 'fix_dir_target_grid': ${FIXsar},
 'mosaic_file_target_grid': ${FIXsar}/$((10#${CRES}))${DOT_OR_USCORE}mosaic.halo$((10#${NH4})).nc,
 'orog_dir_target_grid': ${FIXsar},
 'orog_files_target_grid': ${CRES}${DOT_OR_USCORE}oro_data.tile${TILE_RGNL}.halo$((10#${NH4})).nc,
 'vcoord_file_target_grid': ${FIXam}/global_hyblev.l65.txt,
 'varmap_file': ${CHGRES_CUBE_DIR}/parm/varmap_tables/${varmap_file},
 'data_dir_input_grid': ${extrn_mdl_staging_dir},
 'atm_files_input_grid': ${fn_atm_nemsio},
 'sfc_files_input_grid': ${fn_sfc_nemsio},
 'grib2_file_input_grid': \"${fn_grib2}\",
 'cycle_mon': $((10#${mm})),
 'cycle_day': $((10#${dd})),
 'cycle_hour': $((10#${hh})),
 'convert_atm': True,
 'convert_sfc': True,
 'convert_nst': ${convert_nst},
 'regional': 1,
 'halo_bndy': $((10#${NH4})),
 'halo_blend': $((10#${HALO_BLEND})),
 'input_type': ${input_type},
 'external_model': ${external_model},
 'nsoill_out': $((10#${nsoill_out})),
 'geogrid_file_input_grid': ${geogrid_file_input_grid},
 'vgtyp_from_climo': ${vgtyp_from_climo},
 'sotyp_from_climo': ${sotyp_from_climo},
 'vgfrc_from_climo': ${vgfrc_from_climo},
 'minmax_vgfrc_from_climo': ${minmax_vgfrc_from_climo},
 'lai_from_climo': ${lai_from_climo},
 'tg3_from_soil': ${tg3_from_soil},
}
"
#
# Call the python script to create the namelist file.
#
nml_fn="fort.41"
${USHDIR}/set_namelist.py -q -u "$settings" -o ${nml_fn} || \
  print_err_msg_exit "\
Call to python script set_namelist.py to set the variables in the namelist 
file read in by the ${exec_fn} executable failed.  Parameters passed to 
this script are:
  Name of output namelist file:
    nml_fn = \"${nml_fn}\"
  Namelist settings specified on command line (these have highest precedence):
    settings =
$settings"
#
#-----------------------------------------------------------------------
#
# Run chgres_cube.
#
#-----------------------------------------------------------------------
#
# NOTE:
# Often when the chgres_cube.exe run fails, it still returns a zero re-
# turn code, so the failure isn't picked up the the logical OR (||) be-
# low.  That should be fixed.  This might be due to the APRUN command -
# maybe that is returning a zero exit code even though the exit code 
# of chgres_cube is nonzero.
# A similar thing happens in the forecast task.
#
${APRUN} ${exec_fp} || \
  print_err_msg_exit "\
Call to executable (exec_fp) to generate surface and initial conditions 
(ICs) files for the FV3SAR failed:
  exec_fp = \"${exec_fp}\"
The external model from which the ICs files are to be generated is:
  EXTRN_MDL_NAME_ICS = \"${EXTRN_MDL_NAME_ICS}\"
The external model files that are inputs to the executable (exec_fp) are
located in the following directory:
  extrn_mdl_staging_dir = \"${extrn_mdl_staging_dir}\""
#
#-----------------------------------------------------------------------
#
# Move initial condition, surface, control, and 0-th hour lateral bound-
# ary files to ICs_BCs directory. 
#
#-----------------------------------------------------------------------
#
mv_vrfy out.atm.tile${TILE_RGNL}.nc \
        ${ics_dir}/gfs_data.tile${TILE_RGNL}.halo${NH0}.nc

mv_vrfy out.sfc.tile${TILE_RGNL}.nc \
        ${ics_dir}/sfc_data.tile${TILE_RGNL}.halo${NH0}.nc

mv_vrfy gfs_ctrl.nc ${ics_dir}

mv_vrfy gfs_bndy.nc ${ics_dir}/gfs_bndy.tile${TILE_RGNL}.000.nc
#
#-----------------------------------------------------------------------
#
# Print message indicating successful completion of script.
#
#-----------------------------------------------------------------------
#
print_info_msg "
========================================================================
Initial condition, surface, and zeroth hour lateral boundary condition
files (in NetCDF format) for FV3 generated successfully!!!

Exiting script:  \"${scrfunc_fn}\"
In directory:    \"${scrfunc_dir}\"
========================================================================"
#
#-----------------------------------------------------------------------
#
# Restore the shell options saved at the beginning of this script/func-
# tion.
#
#-----------------------------------------------------------------------
#
{ restore_shell_opts; } > /dev/null 2>&1
